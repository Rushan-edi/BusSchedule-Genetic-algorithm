busArray = [{
    busID: "bus1",
    noOfSeats: 50,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0
},
{
    busID: "bus2",
    noOfSeats: 47,
    route: "120",
    length: 18,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0
},
{
    busID: "bus3",
    noOfSeats: 50,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0
},
{
    busID: "bus4",
    noOfSeats: 53,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0
},
{
    busID: "bus5",
    noOfSeats: 55,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0
},
{
    busID: "bus6",
    noOfSeats: 55,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0
},
{
    busID: "bus7",
    noOfSeats: 58,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0
},
{
    busID: "bus8",
    noOfSeats: 47,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0
},
{
    busID: "bus9",
    noOfSeats: 48,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0
},
{
    busID: "bus10",
    noOfSeats: 50,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0

},
{
    busID: "bus11",
    noOfSeats: 50,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0

},
{
    busID: "bus12",
    noOfSeats: 55,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0

},
{
    busID: "bus13",
    noOfSeats: 58,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0

},
{
    busID: "bus14",
    noOfSeats: 47,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0

},
{
    busID: "bus15",
    noOfSeats: 48,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0

},
{
    busID: "bus16",
    noOfSeats: 50,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0

},
{
    busID: "bus17",
    noOfSeats: 50,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0

},
{
    busID: "bus18",
    noOfSeats: 53,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0

},
{
    busID: "bus19",
    noOfSeats: 58,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0

},
{
    busID: "bus20",
    noOfSeats: 59,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0

},
{
    busID: "bus21",
    noOfSeats: 48,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0

},
{
    busID: "bus22",
    noOfSeats: 45,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0

},
{
    busID: "bus23",
    noOfSeats: 50,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0

},
{
    busID: "bus24",
    noOfSeats: 50,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0

},
{
    busID: "bus25",
    noOfSeats: 50,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0

},
{
    busID: "bus26",
    noOfSeats: 50,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0

},
{
    busID: "bus27",
    noOfSeats: 50,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0

},
{
    busID: "bus28",
    noOfSeats: 50,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0

},
{
    busID: "bus29",
    noOfSeats: 50,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0

},
{
    busID: "bus30",
    noOfSeats: 50,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0

},
{
    busID: "bus31",
    noOfSeats: 50,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0

},
{
    busID: "bus32",
    noOfSeats: 50,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0

},
{
    busID: "bus33",
    noOfSeats: 50,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0

},
{
    busID: "bus34",
    noOfSeats: 50,
    route: "120",
    length: 20,
    totalRevenue: 0,
    numberOfTurns: 0,
    revenueForTheIteration: 0

}
]

var POPULATION_SIZE = 20;
var MUT_PROB = 0.01;
var CROSS_PROB = 0.6;
var NO_OF_SLOTS = 5;
var NO_OF_BUSSES = 8;
var GenerationCount = 0;
var passengerCount = [50, 54, 53, 58, 70, 90];

// var fittestParent;
// var secondFittestParent;
// var leastfittestParent;
// var secondLeastFittestParent;
var id = 0;

var chromosome = function (noOfSlots, noOfBusses) {

    let solution = [];
    let maxValue = (noOfBusses - noOfSlots) + 1;
    let minValue = 1;
    let currentSum = 0;
    let randomValue = 0;
    let isValidRandom;


    for (let i = noOfSlots; i > 0; i--) {


        let sumOfCurrentSolution = solution.reduce((a, b) => a + b, 0);
        let maxRandomForCurrrentIteration = noOfBusses - sumOfCurrentSolution - i + 1;

        if (i == 1) {
            randomValue = maxRandomForCurrrentIteration;
        } else {

            do {
                randomValue = Math.floor((Math.random() * maxValue) + minValue);
                isValidRandom = (maxRandomForCurrrentIteration >= randomValue);

            } while (!isValidRandom);

        }

        do {
            isValidRandom = validateRandomValue((currentSum + randomValue), noOfBusses, );

        }
        while (!isValidRandom);
        currentSum = currentSum + randomValue;

        solution.push(randomValue);

    }

    return solution;

}

function validateRandomValue(currentSum, noOfBusses) {
    return currentSum <= noOfBusses;
}

var calcCost = function (solution, passengerAverage, busArray) {
    let spliceIndex = 0;
    let isEnoughSeats = false;

    let returnEvaluvateJSON = {
        id: 0,
        busAllocation: [],
        busIDs: [],
        fitnessValue: 0
    };

    console.log('----@@ CalCost SOlution @@ ----', solution);
    for (let i = 0; i < solution.length; i++) {
        let sumOfSeats = 0;
        let spliceArray = JSON.parse(JSON.stringify(busArray));
        let newBusArray = spliceArray.splice(spliceIndex, solution[i]);
        spliceIndex = spliceIndex + solution[i];
        newBusArray = JSON.parse(JSON.stringify(newBusArray));
        for (let r = 0; r < newBusArray.length; r++) {
            sumOfSeats = sumOfSeats + newBusArray[r].noOfSeats;
            if (r == 0) {
                returnEvaluvateJSON.busIDs[i] = newBusArray[r].busID;
            } else {
                returnEvaluvateJSON.busIDs[i] += "," + newBusArray[r].busID;
            }

        }

        let slack = sumOfSeats - passengerAverage[i];
        if (slack >= 0) {
            isEnoughSeats = true;
        } else {
            isEnoughSeats = false;
        }
        if (slack < -10) {
            returnEvaluvateJSON.fitnessValue = returnEvaluvateJSON.fitnessValue - 0.5;
        } else if (slack < 0) {
            returnEvaluvateJSON.fitnessValue = returnEvaluvateJSON.fitnessValue - 1;
        } else if (slack > 100) {
            returnEvaluvateJSON.fitnessValue = returnEvaluvateJSON.fitnessValue - 5.2;
        } else if (slack > 90) {
            returnEvaluvateJSON.fitnessValue = returnEvaluvateJSON.fitnessValue - 4.1;
        } else if (slack > 80) {
            returnEvaluvateJSON.fitnessValue = returnEvaluvateJSON.fitnessValue - 3;
        } else if (slack > 70) {
            returnEvaluvateJSON.fitnessValue = returnEvaluvateJSON.fitnessValue - 1.9;
        } else if (slack > 60) {
            returnEvaluvateJSON.fitnessValue = returnEvaluvateJSON.fitnessValue - 0.8;
        } else if (slack > 50) {
            returnEvaluvateJSON.fitnessValue = returnEvaluvateJSON.fitnessValue - 0.7;
        } else if (slack > 40) {
            returnEvaluvateJSON.fitnessValue = returnEvaluvateJSON.fitnessValue - 0.6;
        } else if (slack > 30) {
            returnEvaluvateJSON.fitnessValue = returnEvaluvateJSON.fitnessValue - 0.5;
        } else if (slack > 20) {
            returnEvaluvateJSON.fitnessValue = returnEvaluvateJSON.fitnessValue + 0;
        } else if (slack > 5) {
            returnEvaluvateJSON.fitnessValue = returnEvaluvateJSON.fitnessValue + 1.5;
        } else if (slack > 0) {
            returnEvaluvateJSON.fitnessValue = returnEvaluvateJSON.fitnessValue + 1;
        }

        //Evaluvating whether the busses are divided in a proper way if the number of busses are more than the actual need
        for (let k = 0; k < passengerAverage.length - 1; k++) {
            for (let j = 0; j < passengerAverage.length; j++) {
                if (passengerAverage[k] > passengerAverage[j]) {
                    if (solution[k] < solution[j]) {
                        returnEvaluvateJSON.fitnessValue = returnEvaluvateJSON.fitnessValue - 0.5;
                    } else {
                        returnEvaluvateJSON.fitnessValue = returnEvaluvateJSON.fitnessValue + 0.05;
                    }
                } else {
                    if (solution[k] > solution[j]) {
                        returnEvaluvateJSON.fitnessValue = returnEvaluvateJSON.fitnessValue - 0.5;
                    } else {
                        returnEvaluvateJSON.fitnessValue = returnEvaluvateJSON.fitnessValue + 0.05;
                    }
                }

            }
        }
    }
    id++;
    returnEvaluvateJSON.id = id;
    returnEvaluvateJSON.busAllocation = solution;

    console.log("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
    console.log(returnEvaluvateJSON);
    console.log("----------------------------------------");
    return returnEvaluvateJSON;
}


// console.log("********** :"+chromosome(NO_OF_SLOTS,NO_OF_BUSSES));
// this function generate set of solutions  
var initialPopulation = function (size) {

    var generationJson = {
        allocation: [
        ]
    };
    console.log('BOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOM!!!')
    for (let i = 0; i < size; ++i) {
        let solution;

        solution = chromosome(NO_OF_SLOTS, NO_OF_BUSSES);

        generationJson.allocation.forEach(function (element) {
            if (solution.length === element.busAllocation.length && solution.sort().every(function (value, index) {
                
                return value === element.busAllocation.sort()[index] })) {
                solution = chromosome(NO_OF_SLOTS, NO_OF_BUSSES);
                console.log('BOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOM!!!')
                return;
            }
        }, this);

        let returnEvaluvateSolution = calcCost(solution, [50, 54, 53, 58, 70, 90], busArray);

        generationJson.allocation.push(returnEvaluvateSolution);

    }
    console.log("++++++++ Frist Generation ++++++++++++");
    console.log(JSON.stringify(generationJson));

    return generationJson;

}

var getFittestParent = function (population) {

    let result = JSON.parse(JSON.stringify(population.allocation));

    console.log("++++++++++++++++ population +++++++++++++++++++++++++++++++++");
    console.log(result);
    let max = result[0].fitnessValue;
    let fittestParent = result[0];
    for (let i = 0; i < result.length; i++) {



        if (result[i].fitnessValue > max) {

            max = result[i].fitnessValue;
            fittestParent = result[i];
        }

    }
    console.log("+++++++++++++++ fittest max ++++++++++");
    console.log(max);
    console.log("+++++++++++++++ fittestParent ++++++++++");
    console.log(fittestParent);

    return fittestParent;
}

var getFittestLastSolution = function (population) {
    
        let result = JSON.parse(JSON.stringify(population));
    
        console.log("++++++++++++++++ population +++++++++++++++++++++++++++++++++");
        console.log(result);
        let max = result[0].fitnessValue;
        let fittestParent = result[0];
        for (let i = 0; i < result.length; i++) {
    
    
    
            if (result[i].fitnessValue > max) {
    
                max = result[i].fitnessValue;
                fittestParent = result[i];
            }
    
        }
        console.log("+++++++++++++++ fittest max ++++++++++");
        console.log(max);
        console.log("+++++++++++++++ fittestParent ++++++++++");
        console.log(fittestParent);
    
        return fittestParent;
    }

var getSecondFittestParent = function (population, fittestParent) {

    var result = JSON.parse(JSON.stringify(population.allocation))
    if (result) {


        var max = result[0].fitnessValue;
        let secondFittestParent = result[0];
        for (var i = 0; i < result.length; i++) {

            if (fittestParent.id != result[i].id) {

                if (result[i].fitnessValue > max) {

                    max = result[i].fitnessValue;
                    secondFittestParent = result[i];
                }
            }

        }
        console.log("+++++++++++++++ second fittest max ++++++++");
        console.log(max);
        console.log("+++++++++++++++ second fittestParent ++++++++++");
        console.log(secondFittestParent);

        return secondFittestParent;
    }
};

var getLeastFittestParent = function (population) {

    let result = JSON.parse(JSON.stringify(population.allocation))
    let min = result[0].fitnessValue;
    let leastfittestParent = result[0];
    for (let i = 0; i < result.length; i++) {



        if (result[i].fitnessValue < min) {

            min = result[i].fitnessValue;
            leastfittestParent = result[i];
        }

    }
    console.log("+++++++++++++++ least fittest min ++++++++");
    console.log(min);
    console.log("+++++++++++++++ least fittestParent ++++++++++");
    console.log(leastfittestParent);

    return leastfittestParent;
}

var getSecondLeastFittestParent = function (population, leastfittestParent) {

    let result = JSON.parse(JSON.stringify(population.allocation))
    let min = result[0].fitnessValue;
    let secondLeastFittestParent = result[0];
    console.log("--------- Min min min ------------");
    console.log(min);


    for (let i = 0; i < result.length; i++) {

        if (leastfittestParent.id != result[i].id) {

            if (result[i].fitnessValue < min) {

                min = result[i].fitnessValue;
                secondLeastFittestParent = result[i];
            }
        }

    }
    console.log("+++++++++++++++ second least fittest min ++++++++");
    console.log(min);
    console.log("+++++++++++++++ second least fittestParent ++++++++++");
    console.log(secondLeastFittestParent);
    console.log("------------------------------------------------------");
    return secondLeastFittestParent;
};

var fitnessBaseDSelection = function (resultJSON, fittestParent, secondFittestParent, leastfittestParent, secondLeastFittestParent) {

    let newGenerationJson = {
        allocation: []
    };

    let result = JSON.parse(JSON.stringify(resultJSON.allocation))
    for (let i = 0; i < result.length; i++) {


        console.log("++++++++ compare obj ++++++++++++");

        if (result[i].id == leastfittestParent.id) {

            result[i] = fittestParent;

            //result id  replace as leastparent id
            // result[i].id=leastfittestParent.id

            console.log("true :fittestParent ");
            console.log(result[i]);
            //     console.log("true : "+JSON.stringify(result[i]));
        }
        if (result[i].id == secondLeastFittestParent.id) {

            result[i] = secondFittestParent;
            //result id  replace as second leastparent id
            // result[i].id=secondFittestParent.id

            console.log("true :secondFittestParent ");
            console.log(result[i]);
        }
        // console.log('@@@@@@@@@@@@-----------', result[i]);
        newGenerationJson.allocation.push(result[i]);
    }

    console.log("++++++++ New Generation ++++++++++++");
    console.log(JSON.stringify(newGenerationJson));
    return newGenerationJson;

};

// var crossover = function (fittestParent, secondFittestParent) {

//     console.log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!axe', secondFittestParent);
//     let crossOverPoint = Math.floor(Math.random() * NO_OF_SLOTS);
//     console.log("crossOverPoint  => " + crossOverPoint);
//     // let individualfittest=population[fittestIndex];
//     // let individualsecondFittest=population[secondFittestIndex];

//     if (Math.random(1).toFixed(2) < CROSS_PROB) {

//         for (let i = 0; i < crossOverPoint; i++) {

//             let temp = fittestParent.busAllocation[i];
//             console.log("swaped fittest old => " + temp);
//             fittestParent.busAllocation[i] = secondFittestParent.busAllocation[i]
//             secondFittestParent.busAllocation[i] = temp

//         }
//         let crossoverParrent1 = fittestParent;
//         console.log("++++++++++++ crossoverParrent1 allocation ++++++++");
//         console.log(crossoverParrent1);
//         let crossoverParrent2 = secondFittestParent;
//         console.log("++++++++++++ crossoverParrent2 ++++++++");
//         console.log(crossoverParrent2);
//     }

// };

var crossover = function (fittestParent, secondFittestParent) {

    // console.log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!axe', secondFittestParent);
    let crossOverPoint = Math.floor(Math.random() * NO_OF_SLOTS);
    let weight = 0.5;
    let childArray = [];
    let sum = 0;

    if (Math.random(1).toFixed(2) < CROSS_PROB) {


        for (let i = 0; i < NO_OF_SLOTS; i++) {

            let childVAlue = 0;
            let x = fittestParent.busAllocation[i];
            let y = secondFittestParent.busAllocation[i];

            childVAlue = weight * x + (1 - weight) * y;

            sum += Math.ceil(childVAlue);

            if (sum >= NO_OF_BUSSES - 1) {
                childVAlue = Math.floor(childVAlue);
            }
            else {
                childVAlue = Math.ceil(childVAlue);
            }

            childArray.push(childVAlue);


        }
        console.log("----000000000 Parent one Array before ------------", fittestParent.busAllocation);
        console.log("----000000000 Parent two Array before ------------", secondFittestParent.busAllocation);
        fittestParent.busAllocation = childArray;
        secondFittestParent.busAllocation = childArray;

        console.log("----000000000 Child Array after ------------", childArray);

    }

};

var mutate = function (newGenerationJson) {
    // console.log('--- @@@@ NewGeneration Mutation @@@  -', newGenerationJson);
    let resultAllocation = JSON.parse(JSON.stringify(newGenerationJson.allocation));
    // let mutationPointOne  = Math.floor(Math.random() * population[0].length);
    // let mutationPointTwo  = Math.floor(Math.random() * population[0].length);
    const mutationPointOne = Math.floor(Math.random() * NO_OF_SLOTS);
    const mutationPointTwo = Math.floor(Math.random() * NO_OF_SLOTS);
    console.log("point one: ", mutationPointOne);
    console.log("point two: ", mutationPointTwo);

    // let randomNum=Math.random(1).toFixed(2);


    if (Math.random(1).toFixed(2) < MUT_PROB) {

        const randomAllocation = Math.floor(Math.random() * resultAllocation.length);
        console.log("++++++++++++ randomAllocation allocation ++++++++");
        console.log(resultAllocation[randomAllocation].busAllocation);
        let muteAllocation = resultAllocation[randomAllocation].busAllocation;

        const temp = muteAllocation[mutationPointOne];
        // console.log('TEMP VALUE: ', temp);

        muteAllocation[mutationPointOne] = muteAllocation[mutationPointTwo];
        muteAllocation[mutationPointTwo] = temp;




        console.log("++++++++++++ Mute allocation ++++++++");
        console.log(muteAllocation);

        return newGenerationJson;
        
    }
    return newGenerationJson;

}


var calculateFitness = function (newGenerationJson, busArray) {
    // console.log("-------new generation after calculate-------");
    // console.log(newGenerationJson);


    let solutionNewGen = JSON.parse(JSON.stringify(newGenerationJson.allocation))
    // console.log('--------SOlution change bus allocation ------', solutionNewGen[0].busAllocation);

    for (let i = 0; i < solutionNewGen.length; i++) {


        let returnEvaluvateSolution = calcCost(solutionNewGen[i].busAllocation, [50, 54, 53, 58, 70, 90], busArray)

        newGenerationJson.allocation = returnEvaluvateSolution;

    }

    return solutionNewGen;
}


var runGeneration = function () {

    // initialPopulation(POPULATION_SIZE)

    let generationJson = initialPopulation(POPULATION_SIZE);
    console.log('@@##@#@#@# POPULATION @#@#@#@#', JSON.stringify(generationJson));

    while (GenerationCount != 100) {
        
        let fitparent = getFittestParent(generationJson);
        let secondfitParent = getSecondFittestParent(generationJson, fitparent);
        let leastfitParent = getLeastFittestParent(generationJson);
        let secLeastfitParent = getSecondLeastFittestParent(generationJson, leastfitParent);
        let newGeneration = fitnessBaseDSelection(generationJson, fitparent, secondfitParent, leastfitParent, secLeastfitParent);
        crossover(fitparent, secondfitParent);
        let gjson = mutate(newGeneration);
        let newFit = calculateFitness(gjson, busArray);
        GenerationCount++
        console.log('GENERATION COUNT: ', newFit);
        console.log('-------fittest solution');
        console.log(newFit);
        getFittestLastSolution(newFit);



    }

}

runGeneration();

// let generationJson = initialPopulation(POPULATION_SIZE);
// console.log('@@##@#@#@# POPULATION @#@#@#@#', JSON.stringify(generationJson));

// setTimeout(function () {


//     let fitparent = getFittestParent(generationJson);
//     setTimeout(function () {
//         let secondfitParent = getSecondFittestParent(generationJson, fitparent);

//         setTimeout(function () {
//             let leastfitParent = getLeastFittestParent(generationJson);

//             setTimeout(function () {
//                 let secLeastfitParent = getSecondLeastFittestParent(generationJson, leastfitParent);
//                 setTimeout(function () {
//                     let newGeneration = fitnessBaseDSelection(generationJson, fitparent, secondfitParent, leastfitParent, secLeastfitParent);
//                     crossover(fitparent, secondfitParent);
//                     mutate(newGeneration);
//                     calculateFitness(newGeneration, busArray);
//                 }, 2000);
//             }, 2000);


//         }, 2000);
//     }, 2000);



// }, 2000);
// calculateFitness(newGenerationJson,busArray);

        // getFittestParent(newGenerationJson);
